{"ast":null,"code":"import{Component,useState}from\"react\";import{useDispatch,useSelector}from\"react-redux\";import{toogleShow}from\"../redux/actions\";var taskCompletion=function taskCompletion(parent,child){var index=0,counter=1,result=0;Object.keys(child).map(function(input){//index counts the number of steps, while counter the number of completed steps\nindex=index+1;/** We know that every time we dispatch we have completed a step therfore we need to\n         * take in account that our counter(steps completed) should start in 1 however it\n         * cannot exceeed the length of the number steps therefore we set the counter to be \n         * less than the number of steps if not on the last render it will make the widht >100%\n         */if(child[input].completed>0&&counter<Object.keys(child).length){counter=counter+1;console.log(\"result for counter\",counter);}});if(counter>0){result=counter/index;console.log(\"result for new state\",result);return result;}console.log(\"result for index\",index);console.log(\"result for new state\",result);//base case when taskCompletion gets called we assumed that 1 step was already completed therefore\n//we need to account for it by doing 1(completedtask)/index(number of steps)\n};export default taskCompletion;","map":{"version":3,"sources":["/Users/cait02/Desktop/Begin/React/todo-list/src/components/taskCompletion.js"],"names":["Component","useState","useDispatch","useSelector","toogleShow","taskCompletion","parent","child","index","counter","result","Object","keys","map","input","completed","length","console","log"],"mappings":"AAAA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CACA,OAASC,WAAT,CAAsBC,WAAtB,KAAyC,aAAzC,CACA,OAASC,UAAT,KAA2B,kBAA3B,CAEA,GAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,MAAD,CAASC,KAAT,CAAmB,CACtC,GAAIC,CAAAA,KAAK,CAAG,CAAZ,CAAeC,OAAO,CAAG,CAAzB,CAA4BC,MAAM,CAAG,CAArC,CACAC,MAAM,CAACC,IAAP,CAAYL,KAAZ,EAAmBM,GAAnB,CAAuB,SAAAC,KAAK,CAAI,CAC5B;AACAN,KAAK,CAAGA,KAAK,CAAG,CAAhB,CACA;AACR;AACA;AACA;AACA,WACQ,GAAID,KAAK,CAACO,KAAD,CAAL,CAAaC,SAAb,CAAyB,CAAzB,EAA8BN,OAAO,CAAGE,MAAM,CAACC,IAAP,CAAYL,KAAZ,EAAmBS,MAA/D,CAAuE,CACnEP,OAAO,CAAIA,OAAO,CAAG,CAArB,CACAQ,OAAO,CAACC,GAAR,CAAY,oBAAZ,CAAkCT,OAAlC,EAEH,CACJ,CAbD,EAcA,GAAIA,OAAO,CAAG,CAAd,CAAiB,CACbC,MAAM,CAAID,OAAO,CAAGD,KAApB,CACAS,OAAO,CAACC,GAAR,CAAY,sBAAZ,CAAoCR,MAApC,EACA,MAAOA,CAAAA,MAAP,CACH,CACDO,OAAO,CAACC,GAAR,CAAY,kBAAZ,CAAgCV,KAAhC,EAEAS,OAAO,CAACC,GAAR,CAAY,sBAAZ,CAAoCR,MAApC,EACA;AACA;AACH,CA1BD,CA4BA,cAAeL,CAAAA,cAAf","sourcesContent":["import { Component, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\"\nimport { toogleShow } from \"../redux/actions\"\n\nconst taskCompletion = (parent, child) => {\n    let index = 0, counter = 1, result = 0\n    Object.keys(child).map(input => {\n        //index counts the number of steps, while counter the number of completed steps\n        index = index + 1\n        /** We know that every time we dispatch we have completed a step therfore we need to\n         * take in account that our counter(steps completed) should start in 1 however it\n         * cannot exceeed the length of the number steps therefore we set the counter to be \n         * less than the number of steps if not on the last render it will make the widht >100%\n         */\n        if (child[input].completed > 0 && counter < Object.keys(child).length) {\n            counter = (counter + 1)\n            console.log(\"result for counter\", counter)\n\n        }\n    })\n    if (counter > 0) {\n        result = (counter / index)\n        console.log(\"result for new state\", result)\n        return result\n    }\n    console.log(\"result for index\", index)\n\n    console.log(\"result for new state\", result)\n    //base case when taskCompletion gets called we assumed that 1 step was already completed therefore\n    //we need to account for it by doing 1(completedtask)/index(number of steps)\n}\n\nexport default taskCompletion"]},"metadata":{},"sourceType":"module"}